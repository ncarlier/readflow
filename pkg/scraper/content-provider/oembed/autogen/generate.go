//go:build ignore
// +build ignore

package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"
	"text/template"
	"time"

	"github.com/ncarlier/readflow/pkg/scraper/content-provider/oembed"
)

var tpl = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was auto generated at {{ .Timestamp }}
// using data from {{ .URL }}
package {{ .Package }}

var Providers = {{ .Providers }}
`))

func generateProviders(target, pkg string, supportedProviders map[string]bool) {
	const url = "https://oembed.com/providers.json"

	res, err := http.Get(url)
	die(err)
	defer res.Body.Close()

	body, err := ioutil.ReadAll(res.Body)
	die(err)

	providers := []oembed.Provider{}
	err = json.Unmarshal(body, &providers)
	die(err)

	// Filter in place supported providers
	n := 0
	for _, provider := range providers {
		if supported, exist := supportedProviders[provider.Name]; exist && supported {

			providers[n] = provider
			n++
		}
	}
	providers = providers[:n]

	f, err := os.Create(target)
	die(err)
	defer f.Close()

	code := fmt.Sprintf("%#v", providers)
	code = strings.ReplaceAll(code, "oembed.Provider", "Provider")
	code = strings.ReplaceAll(code, "oembed.Endpoint", "Endpoint")
	// log.Println(code)

	tpl.Execute(f, struct {
		Timestamp time.Time
		URL       string
		Package   string
		Providers string
	}{
		Timestamp: time.Now(),
		URL:       url,
		Package:   pkg,
		Providers: code,
	})
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func main() {
	supportedProviders := map[string]bool{
		"Codepen":        true,
		"Dailymotion":    true,
		"Deviantart.com": true,
		"Facebook":       true,
		"Flickr":         true,
		"Instagram":      true,
		"SlideShare":     true,
		"SoundCloud":     true,
		"Spotify":        true,
		"Tumblr":         true,
		"Twitter":        true,
		"Vimeo":          true,
		"YouTube":        true,
	}
	generateProviders(
		"providers.go",
		"oembed",
		supportedProviders,
	)
}
